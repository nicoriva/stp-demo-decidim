{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n/* eslint-disable require-jsdoc */\n\nimport addEnterBindings from \"src/decidim/editor/modified_enter\";\nimport backspaceBindingsRangeAny from \"src/decidim/editor/modified_backspace_offset_any\";\nimport backspaceBindings from \"src/decidim/editor/modified_backspace_offset1\";\nimport HistoryOverride from \"src/decidim/editor/history_override\";\n\n// Disable warning messages from overwritting modules\nQuill.debug(\"error\");\n\n// It all started with these snippets of code: https://github.com/quilljs/quill/issues/252\nvar Delta = Quill[\"import\"](\"delta\");\nvar Break = Quill[\"import\"](\"blots/break\");\nvar Embed = Quill[\"import\"](\"blots/embed\");\nvar Scroll = Quill[\"import\"](\"blots/scroll\");\nvar Parchment = Quill[\"import\"](\"parchment\");\nQuill.register({\n  \"modules/history\": HistoryOverride\n}, true);\nvar icons = Quill[\"import\"](\"ui/icons\");\nicons.linebreak = \"⏎\";\nvar SmartBreak = /*#__PURE__*/function (_Break) {\n  _inherits(SmartBreak, _Break);\n  var _super = _createSuper(SmartBreak);\n  function SmartBreak() {\n    _classCallCheck(this, SmartBreak);\n    return _super.apply(this, arguments);\n  }\n  _createClass(SmartBreak, [{\n    key: \"length\",\n    value: function length() {\n      return 1;\n    }\n  }, {\n    key: \"value\",\n    value: function value() {\n      return \"\\n\";\n    }\n  }, {\n    key: \"insertInto\",\n    value: function insertInto(parent, ref) {\n      // Embed.prototype.insertInto.call(this, parent, ref);\n      Reflect.apply(Embed.prototype.insertInto, this, [parent, ref]);\n    }\n  }]);\n  return SmartBreak;\n}(Break);\nQuill.register(SmartBreak);\n\n// Override quill/blots/scroll.js\nvar ScrollOvderride = /*#__PURE__*/function (_Scroll) {\n  _inherits(ScrollOvderride, _Scroll);\n  var _super2 = _createSuper(ScrollOvderride);\n  function ScrollOvderride() {\n    _classCallCheck(this, ScrollOvderride);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(ScrollOvderride, [{\n    key: \"optimize\",\n    value: function optimize() {\n      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.batch === true) {\n        return;\n      }\n      this.parchmentOptimize(mutations, context);\n      if (mutations.length > 0) {\n        // quill/core/emitter.js, Emitter.events.SCROLL_OPTIMIZE = \"scroll-optimize\"\n        this.emitter.emit(\"scroll-optimize\", mutations, context);\n      }\n    }\n\n    // Override parchment/src/blot/scroll.ts\n  }, {\n    key: \"parchmentOptimize\",\n    value: function parchmentOptimize() {\n      var _this = this;\n      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // super.optimize(context);\n      Reflect.apply(Parchment.Container.prototype.optimize, this, [context]);\n\n      // We must modify mutations directly, cannot make copy and then modify\n      // let records = [].slice.call(this.observer.takeRecords());\n      var records = _toConsumableArray(this.observer.takeRecords());\n      // Array.push currently seems to be implemented by a non-tail recursive function\n      // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n      var mark = function mark(blot, markParent) {\n        if (!blot || blot === _this) {\n          return;\n        }\n        if (!blot.domNode.parentNode) {\n          return;\n        }\n        if (blot.domNode.__blot && blot.domNode.__blot.mutations === null) {\n          blot.domNode.__blot.mutations = [];\n        }\n        if (markParent) {\n          mark(blot.parent);\n        }\n      };\n      var optimize = function optimize(blot) {\n        // Post-order traversal\n        if (!blot.domNode.__blot) {\n          return;\n        }\n        if (blot instanceof Parchment.Container) {\n          blot.children.forEach(optimize);\n        }\n        blot.optimize(context);\n      };\n      var remaining = mutations;\n      for (var ind = 0; remaining.length > 0; ind += 1) {\n        // MAX_OPTIMIZE_ITERATIONS = 100\n        if (ind >= 100) {\n          throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n        }\n        remaining.forEach(function (mutation) {\n          var blot = Parchment.find(mutation.target, true);\n          if (!blot) {\n            return;\n          }\n          if (blot.domNode === mutation.target) {\n            if (mutation.type === \"childList\") {\n              mark(Parchment.find(mutation.previousSibling, false));\n              mutation.addedNodes.forEach(function (node) {\n                var child = Parchment.find(node, false);\n                mark(child, false);\n                if (child instanceof Parchment.Container) {\n                  child.children.forEach(function (grandChild) {\n                    mark(grandChild, false);\n                  });\n                }\n              });\n            } else if (mutation.type === \"attributes\") {\n              mark(blot.prev);\n            }\n          }\n          mark(blot);\n        });\n        this.children.forEach(optimize);\n        remaining = _toConsumableArray(this.observer.takeRecords());\n        records = remaining.slice();\n        while (records.length > 0) {\n          mutations.push(records.pop());\n        }\n      }\n    }\n  }]);\n  return ScrollOvderride;\n}(Scroll);\n;\nQuill.register(\"blots/scroll\", ScrollOvderride, true);\nParchment.register(ScrollOvderride);\nexport default function lineBreakButtonHandler(quill) {\n  var range = quill.selection.getRange()[0];\n  var currentLeaf = quill.getLeaf(range.index)[0];\n  var nextLeaf = quill.getLeaf(range.index + 1)[0];\n  var previousChar = quill.getText(range.index - 1, 1);\n\n  // Insert a second break if:\n  // At the end of the editor, OR next leaf has a different parent (<p>)\n  if (nextLeaf === null || currentLeaf.parent !== nextLeaf.parent) {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  } else if (previousChar === \"\\n\") {\n    var delta = new Delta().retain(range.index).insert(\"\\n\");\n    quill.updateContents(delta, Quill.sources.USER);\n  } else {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  }\n\n  // Now that we've inserted a line break, move the cursor forward\n  quill.setSelection(range.index + 1, Quill.sources.SILENT);\n}\nQuill.register(\"modules/linebreak\", function (quill) {\n  quill.getModule(\"toolbar\").addHandler(\"linebreak\", function () {\n    lineBreakButtonHandler(quill);\n  });\n  quill.emitter.on(\"editor-ready\", function () {\n    var length = quill.getLength();\n    var text = quill.getText(length - 2, 2);\n\n    // Remove extraneous new lines\n    if (text === \"\\n\\n\") {\n      quill.deleteText(quill.getLength() - 2, 2);\n    }\n  });\n  addEnterBindings(quill);\n  backspaceBindingsRangeAny(quill);\n  backspaceBindings(quill);\n  return;\n});","map":{"version":3,"names":["addEnterBindings","backspaceBindingsRangeAny","backspaceBindings","HistoryOverride","Quill","debug","Delta","Break","Embed","Scroll","Parchment","register","icons","linebreak","SmartBreak","_Break","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","length","insertInto","parent","ref","Reflect","prototype","ScrollOvderride","_Scroll","_super2","optimize","mutations","undefined","context","batch","parchmentOptimize","emitter","emit","_this","Container","records","_toConsumableArray","observer","takeRecords","push","pop","mark","blot","markParent","domNode","parentNode","__blot","children","forEach","remaining","ind","Error","mutation","find","target","type","previousSibling","addedNodes","node","child","grandChild","prev","slice","lineBreakButtonHandler","quill","range","selection","getRange","currentLeaf","getLeaf","index","nextLeaf","previousChar","getText","insertEmbed","delta","retain","insert","updateContents","sources","USER","setSelection","SILENT","getModule","addHandler","on","getLength","text","deleteText"],"sources":["/home/nico/.rbenv/versions/3.0.2/lib/ruby/gems/3.0.0/gems/decidim-core-0.27.3/app/packs/src/decidim/editor/linebreak_module.js"],"sourcesContent":["/* eslint-disable require-jsdoc */\n\nimport addEnterBindings from \"src/decidim/editor/modified_enter\"\nimport backspaceBindingsRangeAny from \"src/decidim/editor/modified_backspace_offset_any\"\nimport backspaceBindings from \"src/decidim/editor/modified_backspace_offset1\"\nimport HistoryOverride from \"src/decidim/editor/history_override\"\n\n// Disable warning messages from overwritting modules\nQuill.debug(\"error\");\n\n// It all started with these snippets of code: https://github.com/quilljs/quill/issues/252\nconst Delta = Quill.import(\"delta\");\nconst Break = Quill.import(\"blots/break\");\nconst Embed = Quill.import(\"blots/embed\");\nconst Scroll = Quill.import(\"blots/scroll\");\nconst Parchment = Quill.import(\"parchment\");\nQuill.register({\"modules/history\": HistoryOverride}, true);\nlet icons = Quill.import(\"ui/icons\");\nicons.linebreak = \"⏎\";\n\nclass SmartBreak extends Break {\n  length() {\n    return 1;\n  }\n\n  value() {\n    return \"\\n\";\n  }\n\n  insertInto(parent, ref) {\n    // Embed.prototype.insertInto.call(this, parent, ref);\n    Reflect.apply(Embed.prototype.insertInto, this, [parent, ref]);\n  }\n}\nQuill.register(SmartBreak);\n\n// Override quill/blots/scroll.js\nclass ScrollOvderride extends Scroll {\n  optimize(mutations = [], context = {}) {\n    if (this.batch === true) {\n      return;\n    }\n\n    this.parchmentOptimize(mutations, context);\n\n    if (mutations.length > 0) {\n      // quill/core/emitter.js, Emitter.events.SCROLL_OPTIMIZE = \"scroll-optimize\"\n      this.emitter.emit(\"scroll-optimize\", mutations, context);\n    }\n  }\n\n  // Override parchment/src/blot/scroll.ts\n  parchmentOptimize(mutations = [], context = {}) {\n    // super.optimize(context);\n    Reflect.apply(Parchment.Container.prototype.optimize, this, [context]);\n\n    // We must modify mutations directly, cannot make copy and then modify\n    // let records = [].slice.call(this.observer.takeRecords());\n    let records = [...this.observer.takeRecords()];\n    // Array.push currently seems to be implemented by a non-tail recursive function\n    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n    while (records.length > 0) {\n      mutations.push(records.pop());\n    }\n    let mark = (blot, markParent) => {\n      if (!blot || blot === this) {\n        return;\n      }\n      if (!blot.domNode.parentNode) {\n        return;\n      }\n      if (blot.domNode.__blot && blot.domNode.__blot.mutations === null) {\n        blot.domNode.__blot.mutations = [];\n      }\n      if (markParent) {\n        mark(blot.parent);\n      }\n    };\n    let optimize = (blot) => {\n      // Post-order traversal\n      if (!blot.domNode.__blot) {\n        return;\n      }\n\n      if (blot instanceof Parchment.Container) {\n        blot.children.forEach(optimize);\n      }\n      blot.optimize(context);\n    };\n    let remaining = mutations;\n    for (let ind = 0; remaining.length > 0; ind += 1) {\n      // MAX_OPTIMIZE_ITERATIONS = 100\n      if (ind >= 100) {\n        throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n      }\n      remaining.forEach((mutation) => {\n        let blot = Parchment.find(mutation.target, true);\n        if (!blot) {\n          return;\n        }\n        if (blot.domNode === mutation.target) {\n          if (mutation.type === \"childList\") {\n            mark(Parchment.find(mutation.previousSibling, false));\n\n            mutation.addedNodes.forEach((node) => {\n              let child = Parchment.find(node, false);\n              mark(child, false);\n              if (child instanceof Parchment.Container) {\n                child.children.forEach(function(grandChild) {\n                  mark(grandChild, false);\n                });\n              }\n            });\n          } else if (mutation.type === \"attributes\") {\n            mark(blot.prev);\n          }\n        }\n        mark(blot);\n      });\n      this.children.forEach(optimize);\n      remaining = [...this.observer.takeRecords()];\n      records = remaining.slice();\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n    }\n  }\n};\nQuill.register(\"blots/scroll\", ScrollOvderride, true);\nParchment.register(ScrollOvderride);\n\nexport default function lineBreakButtonHandler(quill) {\n  let range = quill.selection.getRange()[0];\n  let currentLeaf = quill.getLeaf(range.index)[0];\n  let nextLeaf = quill.getLeaf(range.index + 1)[0];\n  const previousChar = quill.getText(range.index - 1, 1);\n\n  // Insert a second break if:\n  // At the end of the editor, OR next leaf has a different parent (<p>)\n  if (nextLeaf === null || (currentLeaf.parent !== nextLeaf.parent)) {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  } else if (previousChar === \"\\n\") {\n    const delta = new Delta().retain(range.index).insert(\"\\n\");\n    quill.updateContents(delta, Quill.sources.USER);\n  } else {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  }\n\n  // Now that we've inserted a line break, move the cursor forward\n  quill.setSelection(range.index + 1, Quill.sources.SILENT);\n}\n\nQuill.register(\"modules/linebreak\", (quill) => {\n  quill.getModule(\"toolbar\").addHandler(\"linebreak\", () => {\n    lineBreakButtonHandler(quill);\n  });\n\n  quill.emitter.on(\"editor-ready\", () => {\n    const length = quill.getLength();\n    const text = quill.getText(length - 2, 2);\n\n    // Remove extraneous new lines\n    if (text === \"\\n\\n\") {\n      quill.deleteText(quill.getLength() - 2, 2);\n    }\n  });\n\n  addEnterBindings(quill);\n  backspaceBindingsRangeAny(quill);\n  backspaceBindings(quill);\n\n  return;\n});\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}