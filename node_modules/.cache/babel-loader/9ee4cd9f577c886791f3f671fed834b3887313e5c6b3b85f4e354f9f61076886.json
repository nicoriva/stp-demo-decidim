{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { Keyboard } from \"foundation-sites\";\nvar focusGuardClass = \"focusguard\";\nvar focusableNodes = [\"A\", \"IFRAME\", \"OBJECT\", \"EMBED\"];\nvar focusableDisableableNodes = [\"BUTTON\", \"INPUT\", \"TEXTAREA\", \"SELECT\"];\nvar FocusGuard = /*#__PURE__*/function () {\n  function FocusGuard(container) {\n    _classCallCheck(this, FocusGuard);\n    this.container = container;\n    this.guardedElement = null;\n  }\n  _createClass(FocusGuard, [{\n    key: \"trap\",\n    value: function trap(element) {\n      if (this.guardedElement) {\n        Keyboard.releaseFocus($(this.guardedElement));\n      }\n      this.enable();\n      this.guardedElement = element;\n\n      // Call the release focus first so that we don't accidentally add the\n      // keyboard trap twice. Note that the Foundation methods expect the elements\n      // to be jQuery elements which is why we pass them through jQuery.\n      Keyboard.releaseFocus($(element));\n      Keyboard.trapFocus($(element));\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      var _this = this;\n      // Check if the guards already exists due to some other dialog\n      var guards = this.container.querySelectorAll(\":scope > .\".concat(focusGuardClass));\n      if (guards.length > 0) {\n        // Make sure the guards are the first and last element as there have\n        // been changes in the DOM.\n        guards.forEach(function (guard) {\n          if (guard.dataset.position === \"start\") {\n            _this.container.prepend(guard);\n          } else {\n            _this.container.append(guard);\n          }\n        });\n        return;\n      }\n\n      // Add guards at the start and end of the document and attach their focus\n      // listeners\n      var startGuard = this.createFocusGuard(\"start\");\n      var endGuard = this.createFocusGuard(\"end\");\n      this.container.prepend(startGuard);\n      this.container.append(endGuard);\n      startGuard.addEventListener(\"focus\", function () {\n        return _this.handleContainerFocus(startGuard);\n      });\n      endGuard.addEventListener(\"focus\", function () {\n        return _this.handleContainerFocus(endGuard);\n      });\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      var guards = this.container.querySelectorAll(\":scope > .\".concat(focusGuardClass));\n      guards.forEach(function (guard) {\n        return guard.remove();\n      });\n      if (this.guardedElement) {\n        // Note that the Foundation methods expect the elements to be jQuery\n        // elements which is why we pass them through jQuery.\n        Keyboard.releaseFocus($(this.guardedElement));\n        this.guardedElement = null;\n      }\n    }\n  }, {\n    key: \"createFocusGuard\",\n    value: function createFocusGuard(position) {\n      var guard = document.createElement(\"div\");\n      guard.className = focusGuardClass;\n      guard.dataset.position = position;\n      guard.tabIndex = 0;\n      guard.setAttribute(\"aria-hidden\", \"true\");\n      return guard;\n    }\n  }, {\n    key: \"handleContainerFocus\",\n    value: function handleContainerFocus(guard) {\n      var _this2 = this;\n      if (!this.guardedElement) {\n        guard.blur();\n        return;\n      }\n      var visibleNodes = Array.from(this.guardedElement.querySelectorAll(\"*\")).filter(function (item) {\n        return _this2.isVisible(item);\n      });\n      var target = null;\n      if (guard.dataset.position === \"start\") {\n        // Focus at the start guard, so focus the first focusable element after that\n        for (var ind = 0; ind < visibleNodes.length; ind += 1) {\n          if (!this.isFocusGuard(visibleNodes[ind]) && this.isFocusable(visibleNodes[ind])) {\n            target = visibleNodes[ind];\n            break;\n          }\n        }\n      } else {\n        // Focus at the end guard, so focus the first focusable element after that\n        for (var _ind = visibleNodes.length - 1; _ind >= 0; _ind -= 1) {\n          if (!this.isFocusGuard(visibleNodes[_ind]) && this.isFocusable(visibleNodes[_ind])) {\n            target = visibleNodes[_ind];\n            break;\n          }\n        }\n      }\n      if (target) {\n        target.focus();\n      } else {\n        // If no focusable element was found, blur the guard focus\n        guard.blur();\n      }\n    }\n  }, {\n    key: \"isVisible\",\n    value: function isVisible(element) {\n      return element.offsetWidth > 0 || element.offsetHeight > 0;\n    }\n  }, {\n    key: \"isFocusGuard\",\n    value: function isFocusGuard(element) {\n      return element.classList.contains(focusGuardClass);\n    }\n  }, {\n    key: \"isFocusable\",\n    value: function isFocusable(element) {\n      if (focusableNodes.indexOf(element.nodeName) > -1) {\n        return true;\n      }\n      if (focusableDisableableNodes.indexOf(element.nodeName) > -1 || element.getAttribute(\"contenteditable\")) {\n        if (element.getAttribute(\"disabled\")) {\n          return false;\n        }\n        return true;\n      }\n      var tabindex = parseInt(element.getAttribute(\"tabindex\"), 10);\n      if (!isNaN(tabindex) && tabindex >= 0) {\n        return true;\n      }\n      return false;\n    }\n  }]);\n  return FocusGuard;\n}();\nexport { FocusGuard as default };","map":{"version":3,"names":["Keyboard","focusGuardClass","focusableNodes","focusableDisableableNodes","FocusGuard","container","_classCallCheck","guardedElement","_createClass","key","value","trap","element","releaseFocus","$","enable","trapFocus","_this","guards","querySelectorAll","concat","length","forEach","guard","dataset","position","prepend","append","startGuard","createFocusGuard","endGuard","addEventListener","handleContainerFocus","disable","remove","document","createElement","className","tabIndex","setAttribute","_this2","blur","visibleNodes","Array","from","filter","item","isVisible","target","ind","isFocusGuard","isFocusable","_ind","focus","offsetWidth","offsetHeight","classList","contains","indexOf","nodeName","getAttribute","tabindex","parseInt","isNaN","default"],"sources":["/home/nico/.rbenv/versions/3.0.2/lib/ruby/gems/3.0.0/gems/decidim-core-0.27.3/app/packs/src/decidim/focus_guard.js"],"sourcesContent":["import { Keyboard } from \"foundation-sites\"\n\nconst focusGuardClass = \"focusguard\";\nconst focusableNodes = [\"A\", \"IFRAME\", \"OBJECT\", \"EMBED\"];\nconst focusableDisableableNodes = [\"BUTTON\", \"INPUT\", \"TEXTAREA\", \"SELECT\"];\n\nexport default class FocusGuard {\n  constructor(container) {\n    this.container = container;\n    this.guardedElement = null;\n  }\n\n  trap(element) {\n    if (this.guardedElement) {\n      Keyboard.releaseFocus($(this.guardedElement));\n    }\n\n    this.enable();\n    this.guardedElement = element;\n\n    // Call the release focus first so that we don't accidentally add the\n    // keyboard trap twice. Note that the Foundation methods expect the elements\n    // to be jQuery elements which is why we pass them through jQuery.\n    Keyboard.releaseFocus($(element));\n    Keyboard.trapFocus($(element));\n  }\n\n  enable() {\n    // Check if the guards already exists due to some other dialog\n    const guards = this.container.querySelectorAll(`:scope > .${focusGuardClass}`);\n    if (guards.length > 0) {\n      // Make sure the guards are the first and last element as there have\n      // been changes in the DOM.\n      guards.forEach((guard) => {\n        if (guard.dataset.position === \"start\") {\n          this.container.prepend(guard);\n        } else {\n          this.container.append(guard);\n        }\n      })\n\n      return;\n    }\n\n    // Add guards at the start and end of the document and attach their focus\n    // listeners\n    const startGuard = this.createFocusGuard(\"start\");\n    const endGuard = this.createFocusGuard(\"end\");\n\n    this.container.prepend(startGuard);\n    this.container.append(endGuard);\n\n    startGuard.addEventListener(\"focus\", () => this.handleContainerFocus(startGuard));\n    endGuard.addEventListener(\"focus\", () => this.handleContainerFocus(endGuard));\n  }\n\n  disable() {\n    const guards = this.container.querySelectorAll(`:scope > .${focusGuardClass}`);\n    guards.forEach((guard) => guard.remove());\n\n    if (this.guardedElement) {\n      // Note that the Foundation methods expect the elements to be jQuery\n      // elements which is why we pass them through jQuery.\n      Keyboard.releaseFocus($(this.guardedElement));\n      this.guardedElement = null;\n    }\n  }\n\n  createFocusGuard(position) {\n    const guard = document.createElement(\"div\");\n    guard.className = focusGuardClass;\n    guard.dataset.position = position;\n    guard.tabIndex = 0;\n    guard.setAttribute(\"aria-hidden\", \"true\");\n\n    return guard;\n  };\n\n  handleContainerFocus(guard) {\n    if (!this.guardedElement) {\n      guard.blur();\n      return;\n    }\n\n    const visibleNodes = Array.from(this.guardedElement.querySelectorAll(\"*\")).filter((item) => {\n      return this.isVisible(item);\n    });\n\n    let target = null;\n    if (guard.dataset.position === \"start\") {\n      // Focus at the start guard, so focus the first focusable element after that\n      for (let ind = 0; ind < visibleNodes.length; ind += 1) {\n        if (!this.isFocusGuard(visibleNodes[ind]) && this.isFocusable(visibleNodes[ind])) {\n          target = visibleNodes[ind];\n          break;\n        }\n      }\n    } else {\n      // Focus at the end guard, so focus the first focusable element after that\n      for (let ind = visibleNodes.length - 1; ind >= 0; ind -= 1) {\n        if (!this.isFocusGuard(visibleNodes[ind]) && this.isFocusable(visibleNodes[ind])) {\n          target = visibleNodes[ind];\n          break;\n        }\n      }\n    }\n\n    if (target) {\n      target.focus();\n    } else {\n      // If no focusable element was found, blur the guard focus\n      guard.blur();\n    }\n  };\n\n  isVisible(element) {\n    return element.offsetWidth > 0 || element.offsetHeight > 0;\n  }\n\n  isFocusGuard(element) {\n    return element.classList.contains(focusGuardClass);\n  }\n\n  isFocusable(element) {\n    if (focusableNodes.indexOf(element.nodeName) > -1) {\n      return true;\n    }\n    if (focusableDisableableNodes.indexOf(element.nodeName) > -1 || element.getAttribute(\"contenteditable\")) {\n      if (element.getAttribute(\"disabled\")) {\n        return false;\n      }\n      return true;\n    }\n\n    const tabindex = parseInt(element.getAttribute(\"tabindex\"), 10);\n    if (!isNaN(tabindex) && tabindex >= 0) {\n      return true;\n    }\n\n    return false;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}