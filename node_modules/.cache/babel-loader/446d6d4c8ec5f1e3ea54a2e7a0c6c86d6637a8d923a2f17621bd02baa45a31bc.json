{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n/* eslint max-lines: [\"error\", {\"max\": 350, \"skipBlankLines\": true}] */\n\nvar COUNT_KEY = \"%count%\";\n// How often SR announces the message in relation to maximum characters. E.g.\n// if max characters is 1000, screen reader announces the remaining characters\n// every 100 (= 0.1 * 1000) characters. This will be \"floored\" to the closest\n// 100 if the maximum characters > 100. E.g. if max characters is 5500, the\n// threshold is 500 (= Math.floor(550 / 100) * 100). With 100 or less\n// characters, this ratio is omitted and the announce threshold is always set to\n// 10.\nvar SR_ANNOUNCE_THRESHOLD_RATIO = 0.1;\n// The number of characters left after which every keystroke will be announced.\nvar SR_ANNOUNCE_EVERY_THRESHOLD = 10;\nvar DEFAULT_MESSAGES = {\n  charactersAtLeast: {\n    one: \"at least \".concat(COUNT_KEY, \" character\"),\n    other: \"at least \".concat(COUNT_KEY, \" characters\")\n  },\n  charactersLeft: {\n    one: \"\".concat(COUNT_KEY, \" character left\"),\n    other: \"\".concat(COUNT_KEY, \" characters left\")\n  }\n};\nvar MESSAGES = DEFAULT_MESSAGES;\nvar InputCharacterCounter = /*#__PURE__*/function () {\n  function InputCharacterCounter(input) {\n    var _this = this;\n    _classCallCheck(this, InputCharacterCounter);\n    this.$input = input;\n    this.$target = $(this.$input.data(\"remaining-characters\"));\n    this.minCharacters = parseInt(this.$input.attr(\"minlength\"), 10);\n    this.maxCharacters = parseInt(this.$input.attr(\"maxlength\"), 10);\n    this.describeByCounter = typeof this.$input.attr(\"aria-describedby\") === \"undefined\";\n\n    // Define the closest length for the input \"gaps\" defined by the threshold.\n    if (this.maxCharacters > 10) {\n      if (this.maxCharacters > 100) {\n        this.announceThreshold = Math.floor(this.maxCharacters * SR_ANNOUNCE_THRESHOLD_RATIO);\n      } else {\n        this.announceThreshold = 10;\n      }\n\n      // The number of characters left after which every keystroke will be announced.\n      this.announceEveryThreshold = SR_ANNOUNCE_EVERY_THRESHOLD;\n    } else {\n      this.announceThreshold = 1;\n      this.announceEveryThreshold = 1;\n    }\n    var targetId = this.$target.attr(\"id\");\n    if (typeof targetId === \"undefined\") {\n      if (this.$input.attr(\"id\") && this.$input.attr(\"id\").length > 0) {\n        targetId = \"\".concat(this.$input.attr(\"id\"), \"_characters\");\n      } else {\n        targetId = \"characters_\".concat(Math.random().toString(36).substr(2, 9));\n      }\n    }\n    if (this.$target.length > 0) {\n      this.$target.attr(\"id\", targetId);\n    } else {\n      this.$target = $(\"<span id=\\\"\".concat(targetId, \"\\\" class=\\\"form-input-extra-before\\\" />\"));\n\n      // If input is a hidden for WYSIWYG editor add it at the end\n      if (this.$input.parent().is(\".editor\")) {\n        this.$input.parent().after(this.$target);\n      }\n      // Prefix and suffix columns are wrapped in columns, so put the\n      // character counter before that.\n      else if (this.$input.parent().is(\".columns\") && this.$input.parent().parent().is(\".row\")) {\n        this.$input.parent().parent().after(this.$target);\n      } else {\n        this.$input.after(this.$target);\n      }\n    }\n    if (this.$target.length > 0 && (this.maxCharacters > 0 || this.minCharacters > 0)) {\n      // Create the screen reader target element. We don't want to constantly\n      // announce every change to screen reader, only occasionally.\n      this.$srTarget = $(\"<span role=\\\"status\\\" id=\\\"\".concat(targetId, \"_sr\\\" class=\\\"show-for-sr remaining-character-count-sr\\\" />\"));\n      this.$target.before(this.$srTarget);\n      this.$target.attr(\"aria-hidden\", \"true\");\n      this.$userInput = this.$input;\n\n      // In WYSIWYG editors (Quill) we need to find the active editor from the\n      // DOM node. Quill has the experimental \"find\" method that should work\n      // fine in this case\n      if (Quill && this.$input.parent().is(\".editor\")) {\n        // Wait until the next javascript loop so Quill editors are created\n        setTimeout(function () {\n          _this.editor = Quill.find(_this.$input.siblings(\".editor-container\")[0]);\n          _this.$userInput = $(_this.editor.root);\n          _this.initialize();\n        });\n      } else {\n        this.initialize();\n      }\n    }\n  }\n  _createClass(InputCharacterCounter, [{\n    key: \"initialize\",\n    value: function initialize() {\n      this.updateInputLength();\n      this.previousInputLength = this.inputLength;\n      this.bindEvents();\n      this.setDescribedBy(true);\n    }\n  }, {\n    key: \"setDescribedBy\",\n    value: function setDescribedBy(active) {\n      if (!this.describeByCounter) {\n        return;\n      }\n      if (active) {\n        this.$userInput.attr(\"aria-describedby\", this.$srTarget.attr(\"id\"));\n      } else {\n        this.$userInput.removeAttr(\"aria-describedby\");\n      }\n    }\n  }, {\n    key: \"bindEvents\",\n    value: function bindEvents() {\n      var _this2 = this;\n      if (this.editor) {\n        this.editor.on(\"text-change\", function () {\n          _this2.handleInput();\n        });\n      } else {\n        this.$userInput.on(\"input\", function () {\n          _this2.handleInput();\n        });\n      }\n      this.$userInput.on(\"keyup\", function () {\n        _this2.updateStatus();\n      });\n      this.$userInput.on(\"focus\", function () {\n        _this2.updateScreenReaderStatus();\n      });\n      this.$userInput.on(\"blur\", function () {\n        _this2.updateScreenReaderStatus();\n        _this2.setDescribedBy(true);\n      });\n      if (this.$userInput.get(0) !== null) {\n        this.$userInput.get(0).addEventListener(\"emoji.added\", function () {\n          _this2.updateStatus();\n        });\n      }\n      this.updateStatus();\n      this.updateScreenReaderStatus();\n    }\n  }, {\n    key: \"getInputLength\",\n    value: function getInputLength() {\n      return this.inputLength;\n    }\n  }, {\n    key: \"updateInputLength\",\n    value: function updateInputLength() {\n      this.previousInputLength = this.inputLength;\n      if (this.editor) {\n        this.inputLength = this.editor.getLength();\n      } else {\n        this.inputLength = this.$input.val().length;\n      }\n    }\n  }, {\n    key: \"handleInput\",\n    value: function handleInput() {\n      this.updateInputLength();\n      this.checkScreenReaderUpdate();\n      // If the input is \"described by\" the character counter, some screen\n      // readers (NVDA) announce the status twice when it is updated. By\n      // removing the aria-describedby attribute while the user is typing makes\n      // the screen reader announce the status only once.\n      this.setDescribedBy(false);\n    }\n\n    /**\n     * This compares the current inputLength to the previous value and decides\n     * whether the user is currently adding or deleting characters from the view.\n     *\n     * @returns {String} The input direction either \"ins\" for insert or \"del\" for\n     *   delete.\n     */\n  }, {\n    key: \"getInputDirection\",\n    value: function getInputDirection() {\n      if (this.inputLength < this.previousInputLength) {\n        return \"del\";\n      }\n      return \"ins\";\n    }\n  }, {\n    key: \"getScreenReaderLength\",\n    value: function getScreenReaderLength() {\n      var currentLength = this.getInputLength();\n      if (this.maxCharacters < 10) {\n        return currentLength;\n      } else if (this.maxCharacters - currentLength <= this.announceEveryThreshold) {\n        return currentLength;\n      }\n      var srLength = currentLength - currentLength % this.announceThreshold;\n\n      // Prevent the screen reader telling too many characters left if the user\n      // deletes a characters. This can cause confusing experience e.g. when the\n      // user is closing the maximum amount of characters, so if the previous\n      // announcement was \"10 characters left\" and the user removes one character,\n      // the screen reader would announce \"100 characters left\" next time (when\n      // they actually have only 11 characters left). Similar when they are\n      // deleting a character at 900 characters, the screen reader would announce\n      // \"1000 characters left\" even when they only have 901 characters left.\n      if (this.getInputDirection() === \"del\") {\n        // The first branch makes sure that if the SR length matches the actual\n        // length, it will be always announced.\n        if (srLength === currentLength) {\n          return srLength;\n          // The second branch checks that if we are at the final threshold, we\n          // should not announce \"0 characters left\" when the user deletes more than\n          // the \"announce after every stroke\" limit (this.announceEveryThreshold).\n        } else if (this.maxCharacters - srLength === this.announceThreshold) {\n          return this.announcedAt || currentLength;\n          // The third branch checks that when deleting characters, we should\n          // announce the next threshold to get accurate annoucement. E.g. when we\n          // have 750 characters left and the user deletes 100 characters at once,\n          // we should announce \"700 characters left\" after that deletion.\n        } else if (srLength < currentLength) {\n          return srLength + this.announceThreshold;\n        }\n        // This fixes an issue in the following situation:\n        // 1. 750 characters left\n        // 2. Delete 100 characters in a row\n        // 3. SR: \"800 characters left\" (actual 850)\n        // 4. Type one additional character\n        // 5. Without this, SR would announce \"900 characters left\" = confusing\n      } else if (srLength < this.announcedAt) {\n        return this.announcedAt;\n      }\n      return srLength;\n    }\n  }, {\n    key: \"getMessages\",\n    value: function getMessages() {\n      var currentLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var showMessages = [];\n      var inputLength = currentLength;\n      if (inputLength === null) {\n        inputLength = this.getInputLength();\n      }\n      if (this.minCharacters > 0) {\n        var message = MESSAGES.charactersAtLeast.other;\n        if (this.minCharacters === 1) {\n          message = MESSAGES.charactersAtLeast.one;\n        }\n        showMessages.push(message.replace(COUNT_KEY, this.minCharacters));\n      }\n      if (this.maxCharacters > 0) {\n        var remaining = this.maxCharacters - inputLength;\n        var _message = MESSAGES.charactersLeft.other;\n        if (remaining === 1) {\n          _message = MESSAGES.charactersLeft.one;\n        }\n        this.$input[0].dispatchEvent(new CustomEvent(\"characterCounter\", {\n          detail: {\n            remaining: remaining\n          }\n        }));\n        showMessages.push(_message.replace(COUNT_KEY, remaining));\n      }\n      return showMessages;\n    }\n  }, {\n    key: \"updateStatus\",\n    value: function updateStatus() {\n      this.$target.text(this.getMessages().join(\", \"));\n    }\n  }, {\n    key: \"checkScreenReaderUpdate\",\n    value: function checkScreenReaderUpdate() {\n      if (this.maxCharacters < 1) {\n        return;\n      }\n      var currentLength = this.getScreenReaderLength();\n      if (currentLength === this.announcedAt) {\n        return;\n      }\n      this.announcedAt = currentLength;\n      this.updateScreenReaderStatus(currentLength);\n    }\n  }, {\n    key: \"updateScreenReaderStatus\",\n    value: function updateScreenReaderStatus() {\n      var currentLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      this.$srTarget.text(this.getMessages(currentLength).join(\", \"));\n    }\n  }], [{\n    key: \"configureMessages\",\n    value: function configureMessages(messages) {\n      MESSAGES = $.extend(DEFAULT_MESSAGES, messages);\n    }\n  }]);\n  return InputCharacterCounter;\n}();\nexport { InputCharacterCounter as default };\nvar createCharacterCounter = function createCharacterCounter($input) {\n  if (typeof $input !== \"undefined\" && $input.length) {\n    $input.data(\"remaining-characters-counter\", new InputCharacterCounter($input));\n  }\n};\n$(function () {\n  $(\"input[type='text'], textarea, .editor>input[type='hidden']\").each(function (_i, elem) {\n    var $input = $(elem);\n    if (!$input.is(\"[minlength]\") && !$input.is(\"[maxlength]\")) {\n      return;\n    }\n    createCharacterCounter($input);\n  });\n});\nexport { InputCharacterCounter, createCharacterCounter };","map":{"version":3,"names":["COUNT_KEY","SR_ANNOUNCE_THRESHOLD_RATIO","SR_ANNOUNCE_EVERY_THRESHOLD","DEFAULT_MESSAGES","charactersAtLeast","one","concat","other","charactersLeft","MESSAGES","InputCharacterCounter","input","_this","_classCallCheck","$input","$target","$","data","minCharacters","parseInt","attr","maxCharacters","describeByCounter","announceThreshold","Math","floor","announceEveryThreshold","targetId","length","random","toString","substr","parent","is","after","$srTarget","before","$userInput","Quill","setTimeout","editor","find","siblings","root","initialize","_createClass","key","value","updateInputLength","previousInputLength","inputLength","bindEvents","setDescribedBy","active","removeAttr","_this2","on","handleInput","updateStatus","updateScreenReaderStatus","get","addEventListener","getInputLength","getLength","val","checkScreenReaderUpdate","getInputDirection","getScreenReaderLength","currentLength","srLength","announcedAt","getMessages","arguments","undefined","showMessages","message","push","replace","remaining","_message","dispatchEvent","CustomEvent","detail","text","join","configureMessages","messages","extend","default","createCharacterCounter","each","_i","elem"],"sources":["/home/nico/.rbenv/versions/3.0.2/lib/ruby/gems/3.0.0/gems/decidim-core-0.27.3/app/packs/src/decidim/input_character_counter.js"],"sourcesContent":["/* eslint max-lines: [\"error\", {\"max\": 350, \"skipBlankLines\": true}] */\n\nconst COUNT_KEY = \"%count%\";\n// How often SR announces the message in relation to maximum characters. E.g.\n// if max characters is 1000, screen reader announces the remaining characters\n// every 100 (= 0.1 * 1000) characters. This will be \"floored\" to the closest\n// 100 if the maximum characters > 100. E.g. if max characters is 5500, the\n// threshold is 500 (= Math.floor(550 / 100) * 100). With 100 or less\n// characters, this ratio is omitted and the announce threshold is always set to\n// 10.\nconst SR_ANNOUNCE_THRESHOLD_RATIO = 0.1;\n// The number of characters left after which every keystroke will be announced.\nconst SR_ANNOUNCE_EVERY_THRESHOLD = 10;\nconst DEFAULT_MESSAGES = {\n  charactersAtLeast: {\n    one: `at least ${COUNT_KEY} character`,\n    other: `at least ${COUNT_KEY} characters`\n  },\n  charactersLeft: {\n    one: `${COUNT_KEY} character left`,\n    other: `${COUNT_KEY} characters left`\n  }\n};\nlet MESSAGES = DEFAULT_MESSAGES;\n\nexport default class InputCharacterCounter {\n  static configureMessages(messages) {\n    MESSAGES = $.extend(DEFAULT_MESSAGES, messages);\n  }\n\n  constructor(input) {\n    this.$input = input;\n    this.$target = $(this.$input.data(\"remaining-characters\"));\n    this.minCharacters = parseInt(this.$input.attr(\"minlength\"), 10);\n    this.maxCharacters = parseInt(this.$input.attr(\"maxlength\"), 10);\n    this.describeByCounter = typeof this.$input.attr(\"aria-describedby\") === \"undefined\";\n\n    // Define the closest length for the input \"gaps\" defined by the threshold.\n    if (this.maxCharacters > 10) {\n      if (this.maxCharacters > 100) {\n        this.announceThreshold = Math.floor(this.maxCharacters * SR_ANNOUNCE_THRESHOLD_RATIO);\n      } else {\n        this.announceThreshold = 10;\n      }\n\n      // The number of characters left after which every keystroke will be announced.\n      this.announceEveryThreshold = SR_ANNOUNCE_EVERY_THRESHOLD;\n    } else {\n      this.announceThreshold = 1;\n      this.announceEveryThreshold = 1;\n    }\n\n    let targetId = this.$target.attr(\"id\");\n    if (typeof targetId === \"undefined\") {\n      if (this.$input.attr(\"id\") && this.$input.attr(\"id\").length > 0) {\n        targetId = `${this.$input.attr(\"id\")}_characters`;\n      } else {\n        targetId = `characters_${Math.random().toString(36).substr(2, 9)}`;\n      }\n    }\n\n    if (this.$target.length > 0) {\n      this.$target.attr(\"id\", targetId)\n    } else {\n      this.$target = $(`<span id=\"${targetId}\" class=\"form-input-extra-before\" />`)\n\n      // If input is a hidden for WYSIWYG editor add it at the end\n      if (this.$input.parent().is(\".editor\")) {\n        this.$input.parent().after(this.$target);\n      }\n      // Prefix and suffix columns are wrapped in columns, so put the\n      // character counter before that.\n      else if (\n        this.$input.parent().is(\".columns\") &&\n        this.$input.parent().parent().is(\".row\")\n      ) {\n        this.$input.parent().parent().after(this.$target);\n      } else {\n        this.$input.after(this.$target);\n      }\n    }\n\n    if (this.$target.length > 0 && (this.maxCharacters > 0 || this.minCharacters > 0)) {\n      // Create the screen reader target element. We don't want to constantly\n      // announce every change to screen reader, only occasionally.\n      this.$srTarget = $(\n        `<span role=\"status\" id=\"${targetId}_sr\" class=\"show-for-sr remaining-character-count-sr\" />`\n      );\n      this.$target.before(this.$srTarget);\n      this.$target.attr(\"aria-hidden\", \"true\");\n\n      this.$userInput = this.$input;\n\n      // In WYSIWYG editors (Quill) we need to find the active editor from the\n      // DOM node. Quill has the experimental \"find\" method that should work\n      // fine in this case\n      if (Quill && this.$input.parent().is(\".editor\")) {\n        // Wait until the next javascript loop so Quill editors are created\n        setTimeout(() => {\n          this.editor = Quill.find(this.$input.siblings(\".editor-container\")[0]);\n          this.$userInput = $(this.editor.root);\n          this.initialize();\n        });\n      } else {\n        this.initialize();\n      }\n    }\n  }\n\n  initialize() {\n    this.updateInputLength();\n    this.previousInputLength = this.inputLength;\n\n    this.bindEvents();\n    this.setDescribedBy(true);\n  }\n\n  setDescribedBy(active) {\n    if (!this.describeByCounter) {\n      return;\n    }\n\n    if (active) {\n      this.$userInput.attr(\"aria-describedby\", this.$srTarget.attr(\"id\"));\n    } else {\n      this.$userInput.removeAttr(\"aria-describedby\");\n    }\n  }\n\n  bindEvents() {\n    if (this.editor) {\n      this.editor.on(\"text-change\", () => {\n        this.handleInput();\n      });\n    } else {\n      this.$userInput.on(\"input\", () => {\n        this.handleInput();\n      });\n    }\n\n    this.$userInput.on(\"keyup\", () => {\n      this.updateStatus();\n    });\n    this.$userInput.on(\"focus\", () => {\n      this.updateScreenReaderStatus();\n    });\n    this.$userInput.on(\"blur\", () => {\n      this.updateScreenReaderStatus();\n      this.setDescribedBy(true);\n    });\n    if (this.$userInput.get(0) !== null) {\n      this.$userInput.get(0).addEventListener(\"emoji.added\", () => {\n        this.updateStatus();\n      });\n    }\n    this.updateStatus();\n    this.updateScreenReaderStatus();\n  }\n\n  getInputLength() {\n    return this.inputLength;\n  }\n\n  updateInputLength() {\n    this.previousInputLength = this.inputLength;\n    if (this.editor) {\n      this.inputLength = this.editor.getLength();\n    } else {\n      this.inputLength = this.$input.val().length;\n    }\n  }\n\n  handleInput() {\n    this.updateInputLength();\n    this.checkScreenReaderUpdate();\n    // If the input is \"described by\" the character counter, some screen\n    // readers (NVDA) announce the status twice when it is updated. By\n    // removing the aria-describedby attribute while the user is typing makes\n    // the screen reader announce the status only once.\n    this.setDescribedBy(false);\n  }\n\n  /**\n   * This compares the current inputLength to the previous value and decides\n   * whether the user is currently adding or deleting characters from the view.\n   *\n   * @returns {String} The input direction either \"ins\" for insert or \"del\" for\n   *   delete.\n   */\n  getInputDirection() {\n    if (this.inputLength < this.previousInputLength) {\n      return \"del\";\n    }\n\n    return \"ins\";\n  }\n\n  getScreenReaderLength() {\n    const currentLength = this.getInputLength();\n    if (this.maxCharacters < 10) {\n      return currentLength;\n    } else if (this.maxCharacters - currentLength <= this.announceEveryThreshold) {\n      return currentLength;\n    }\n\n    const srLength = currentLength - currentLength % this.announceThreshold;\n\n    // Prevent the screen reader telling too many characters left if the user\n    // deletes a characters. This can cause confusing experience e.g. when the\n    // user is closing the maximum amount of characters, so if the previous\n    // announcement was \"10 characters left\" and the user removes one character,\n    // the screen reader would announce \"100 characters left\" next time (when\n    // they actually have only 11 characters left). Similar when they are\n    // deleting a character at 900 characters, the screen reader would announce\n    // \"1000 characters left\" even when they only have 901 characters left.\n    if (this.getInputDirection() === \"del\") {\n      // The first branch makes sure that if the SR length matches the actual\n      // length, it will be always announced.\n      if (srLength === currentLength) {\n        return srLength;\n      // The second branch checks that if we are at the final threshold, we\n      // should not announce \"0 characters left\" when the user deletes more than\n      // the \"announce after every stroke\" limit (this.announceEveryThreshold).\n      } else if (this.maxCharacters - srLength === this.announceThreshold) {\n        return this.announcedAt || currentLength;\n      // The third branch checks that when deleting characters, we should\n      // announce the next threshold to get accurate annoucement. E.g. when we\n      // have 750 characters left and the user deletes 100 characters at once,\n      // we should announce \"700 characters left\" after that deletion.\n      } else if (srLength < currentLength) {\n        return srLength + this.announceThreshold;\n      }\n    // This fixes an issue in the following situation:\n    // 1. 750 characters left\n    // 2. Delete 100 characters in a row\n    // 3. SR: \"800 characters left\" (actual 850)\n    // 4. Type one additional character\n    // 5. Without this, SR would announce \"900 characters left\" = confusing\n    } else if (srLength < this.announcedAt) {\n      return this.announcedAt;\n    }\n\n    return srLength;\n  }\n\n  getMessages(currentLength = null) {\n    const showMessages = [];\n    let inputLength = currentLength;\n    if (inputLength === null) {\n      inputLength = this.getInputLength()\n    }\n\n    if (this.minCharacters > 0) {\n      let message = MESSAGES.charactersAtLeast.other;\n      if (this.minCharacters === 1) {\n        message = MESSAGES.charactersAtLeast.one;\n      }\n      showMessages.push(message.replace(COUNT_KEY, this.minCharacters));\n    }\n\n    if (this.maxCharacters > 0) {\n      const remaining = this.maxCharacters - inputLength;\n      let message = MESSAGES.charactersLeft.other;\n      if (remaining === 1) {\n        message = MESSAGES.charactersLeft.one;\n      }\n      this.$input[0].dispatchEvent(\n        new CustomEvent(\"characterCounter\", {detail: {remaining: remaining}})\n      );\n      showMessages.push(message.replace(COUNT_KEY, remaining));\n    }\n\n    return showMessages;\n  }\n\n  updateStatus() {\n    this.$target.text(this.getMessages().join(\", \"));\n  }\n\n  checkScreenReaderUpdate() {\n    if (this.maxCharacters < 1) {\n      return;\n    }\n\n    const currentLength = this.getScreenReaderLength();\n    if (currentLength === this.announcedAt) {\n      return;\n    }\n\n    this.announcedAt = currentLength;\n    this.updateScreenReaderStatus(currentLength);\n  }\n\n  updateScreenReaderStatus(currentLength = null) {\n    this.$srTarget.text(this.getMessages(currentLength).join(\", \"));\n  }\n}\n\nconst createCharacterCounter = ($input) => {\n  if (typeof $input !== \"undefined\" && $input.length) {\n    $input.data(\"remaining-characters-counter\", new InputCharacterCounter($input));\n  }\n}\n\n$(() => {\n  $(\"input[type='text'], textarea, .editor>input[type='hidden']\").each((_i, elem) => {\n    const $input = $(elem);\n\n    if (!$input.is(\"[minlength]\") && !$input.is(\"[maxlength]\")) {\n      return;\n    }\n\n    createCharacterCounter($input);\n  });\n});\n\nexport {InputCharacterCounter, createCharacterCounter};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}